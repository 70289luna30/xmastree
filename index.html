<html lang="zh-TW"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åå­¸é™¢ï½œAI è–èª•æ¨¹äº’å‹•ï¼ˆå®Œæ•´ç‰ˆï¼‰</title>

  <!-- âœ… Google Fonts: Corinthia -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
  <link href="https://fonts.googleapis.com/css2?family=Corinthia:wght@400;700&amp;display=swap" rel="stylesheet">

  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
    #canvas-container { position: fixed; inset: 0; z-index: 1; }

    #status {
      position: fixed; inset: 0; display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      color: #fff; z-index: 30;
      background: rgba(0,0,0,0.65);
      text-align: center;
      padding: 24px;
    }
    #status h1 { margin: 0 0 12px 0; font-size: 22px; }
    #status p { margin: 0; color: rgba(255,255,255,0.75); font-size: 14px; line-height: 1.7; }
    #start-btn {
      margin-top: 18px; padding: 12px 22px; border-radius: 999px;
      border: 0; cursor: pointer; font-weight: 800;
      background: #22ff88; color: #00150a;
      box-shadow: 0 0 22px rgba(34,255,136,.35);
    }

    /* æ”å½±æ©Ÿé è¦½ */
    #video-preview {
      position: fixed; left: 16px; bottom: 16px;
      width: 160px; height: 120px;
      border-radius: 14px;
      transform: scaleX(-1);
      border: 2px solid rgba(255,255,255,0.18);
      z-index: 10;
      object-fit: cover;
      background: #000;
      opacity: 0.55;
    }

    /* âœ… å·¨å¤§æ¨™é¡Œï¼šCorinthia + ç´…/é»ƒç™¼å…‰ */
    #big-title{
      position: fixed;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 13;
      pointer-events: none;
      white-space: nowrap;
      font-family: "Corinthia", cursive;
      font-weight: 700;
      color: #ffffff;
      font-size: clamp(64px, 9vw, 140px);
      line-height: 1;
      letter-spacing: 0.5px;

      /* ç´… / é»ƒéœ“è™¹ç™¼å…‰ */
      text-shadow:
        0 0 10px rgba(255, 60, 60, 0.90),
        0 0 18px rgba(255, 60, 60, 0.65),
        0 0 10px rgba(255, 215, 0, 0.85),
        0 0 22px rgba(255, 215, 0, 0.55),
        0 10px 35px rgba(0, 0, 0, 0.55);
      filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.30));
    }

    /* æ–‡å­—å‰¯æ¨™/CTAï¼ˆä¿ç•™ï¼šå¦‚æœä½ è¦å°±ç•™ï¼Œä¸è¦å°±åˆª #text-layer æ•´æ®µ HTMLï¼‰ */
    #text-layer{
      position: fixed;
      top: 140px;            /* âœ… å› ç‚ºå¤§æ¨™é¡Œå¾ˆå¤§ï¼Œå‰¯æ¨™å¾€ä¸‹ç§» */
      left: 50%;
      transform: translateX(-50%);
      z-index: 12;
      width: min(92vw, 760px);
      text-align: center;
      pointer-events: none;
      color: rgba(255,255,255,0.92);
      text-shadow: 0 6px 18px rgba(0,0,0,0.55);
    }
    #text-layer .subline{
      margin-top: 6px;
      font-size: clamp(12px, 2.8vw, 16px);
      color: rgba(255,255,255,0.78);
    }
    #text-layer .cta{
      margin-top: 10px;
      font-size: clamp(11px, 2.6vw, 14px);
      color: rgba(34,255,136,0.95);
    }

    /* çˆ†ç‚¸è§£é–åœ–ç‰‡å¡ */
    #reveal-card{
      position: fixed;
      left: 50%;
      top: 54%;
      transform: translate(-50%, -50%) scale(0.92);
      width: min(82vw, 380px);
      background: rgba(10,10,18,0.72);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 12px;
      z-index: 20;
      opacity: 0;
      transition: 0.28s ease;
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
      backdrop-filter: blur(10px);
      pointer-events: none;
    }
    #reveal-card.show{
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    #reveal-card img{
      width: 100%;
      border-radius: 14px;
      display: block;
    }
    #reveal-card .reveal-text{
      margin-top: 10px;
      font-size: 13px;
      color: rgba(255,255,255,0.86);
      text-align: center;
      line-height: 1.45;
    }

    /* UI Panel */
    #ui-panel {
      position: fixed; top: 16px; right: 16px;
      width: 300px; padding: 16px;
      background: rgba(20,20,35,0.85);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      color: #fff; z-index: 10;
      box-shadow: 0 8px 32px rgba(0,0,0,0.45);
    }
    #ui-panel h2 { margin: 0 0 10px 0; font-size: 16px; letter-spacing: .5px; }
    .help { font-size: 12px; color: rgba(255,255,255,0.68); line-height: 1.55; }
    .divider { height: 1px; background: rgba(255,255,255,0.12); margin: 12px 0; }

    .color-row { display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0 12px 0; }
    .cbtn {
      width: 20px; height: 20px; border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.78);
      cursor: pointer;
      box-shadow: 0 0 12px rgba(255,255,255,0.18);
      background: #fff;
    }
    .cbtn[data-c="#22ff88"]{ background:#22ff88; }
    .cbtn[data-c="#ff4d4d"]{ background:#ff4d4d; }
    .cbtn[data-c="#ffd700"]{ background:#ffd700; }
    .cbtn[data-c="#6c5ce7"]{ background:#6c5ce7; }
    .cbtn[data-c="#ffffff"]{ background:#ffffff; }
    .cbtn[data-c="#6dd5ff"]{ background:#6dd5ff; }

    .toggle-row { display:flex; align-items:center; justify-content:space-between; gap: 12px; margin-top: 6px; }
    .toggle-row label { font-size: 12px; color: rgba(255,255,255,0.75); }
    .switch {
      width: 44px; height: 24px; background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 999px; position: relative; cursor: pointer;
    }
    .knob {
      width: 18px; height: 18px; border-radius: 50%;
      background: rgba(255,255,255,0.85);
      position: absolute; top: 50%; transform: translateY(-50%);
      left: 3px; transition: 0.18s;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    }
    .switch.on .knob { left: 23px; background: #22ff88; }

    /* éŸ³æ¨‚æŒ‰éˆ• */
    #audio-btn{
      margin-top: 10px;
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
      cursor: pointer;
      font-weight: 700;
    }

    /* å…‰é»ç‰¹æ•ˆ */
    .sparkle {
      position: fixed; width: 44px; height: 44px;
      background: radial-gradient(circle, #fff 10%, #ffd700 40%, transparent 70%);
      border-radius: 50%;
      pointer-events: none; z-index: 99;
      animation: flash 0.55s ease-out forwards;
      box-shadow: 0 0 22px #ffd700;
      mix-blend-mode: screen;
    }
    @keyframes flash {
      0% { opacity: 1; transform: scale(0.6); }
      100% { opacity: 0; transform: scale(2.7); }
    }
  </style>
</head>
<body>
  <div id="status">
    <h1>ğŸ„ AI è–èª•æ¨¹äº’å‹•ï¼ˆå®Œæ•´ç‰ˆï¼‰</h1>
    <p>
      âœ… å¼µé–‹æ‰‹ï¼šæ¨¹ç‚¸é–‹ï¼ˆè¶Šå¼µè¶Šçˆ†ï¼‰<br>
      ğŸ‘‹ æ®æ‰‹ï¼šæ¨¹å‘å·¦/å³ä½ç§»<br>
      ğŸ”„ æ‰‹æŒä¸Šä¸‹ï¼š360 æ—‹è½‰<br>
      ğŸ‘Œ æåˆï¼šé­”æ³•å…‰é»<br>
      â„ï¸ èƒŒæ™¯é£„é›ªï¼šè‡ªå‹•
    </p>
    <button id="start-btn">âœ¨ é–‹å§‹é«”é©—</button>
  </div>

  <video id="video-preview" playsinline=""></video>

  <!-- âœ… ä½ è¦çš„å·¨å¤§æ¨™é¡Œ -->
  <div id="big-title">Merry Christmas</div>

  <!--ï¼ˆå¯ç•™å¯åˆªï¼šå‰¯æ¨™/CTAï¼‰-->
  <div id="text-layer">
    <div class="subline">æ‰“é–‹ç¶²å€ã€å‹•ä¸€å‹•æ‰‹ï¼Œé©šå–œæ‰æœƒå‡ºç¾</div>
    <div class="cta">å–œæ­¡é€™ç¨®äº’å‹•ï¼Ÿä¸»é é€£çµ âœ ç¤¾åœ˜çœ‹æ›´å¤š</div>
  </div>

  <!-- çˆ†ç‚¸è§£é–åœ–ç‰‡ -->
  <div id="reveal-card">
    <img id="reveal-img" src="./my_xmas_photo.jpg" alt="Surprise">
    <div class="reveal-text">çµ¦ä½ ä¸€å€‹ä¸ç„¡èŠçš„è–èª•é©šå–œ âœ¨<br>ï¼ˆå¼µé–‹æ‰‹ â†’ è§£é–ï¼‰</div>
  </div>

  <!-- èƒŒæ™¯éŸ³æ¨‚ -->
  <audio id="bgm" src="./xmas_song.mp3" loop="" preload="auto"></audio>

  <div id="ui-panel">
    <h2>âœ¨ è–èª•æ¨¹æ§åˆ¶å°</h2>

    <div class="help">æ¨¹é«”é¡è‰²ï¼ˆé»ä¸€ä¸‹ç«‹å³æ›ï¼‰</div>
    <div class="color-row">
      <button class="cbtn" data-c="#22ff88" aria-label="green"></button>
      <button class="cbtn" data-c="#ff4d4d" aria-label="red"></button>
      <button class="cbtn" data-c="#ffd700" aria-label="gold"></button>
      <button class="cbtn" data-c="#6c5ce7" aria-label="purple"></button>
      <button class="cbtn" data-c="#ffffff" aria-label="white"></button>
      <button class="cbtn" data-c="#6dd5ff" aria-label="iceblue"></button>
    </div>

    <div class="toggle-row">
      <label>æ¨¹é«”æ¼¸å±¤ï¼ˆç¶ â†’é‡‘ï¼‰</label>
      <div id="gradSwitch" class="switch on"><div class="knob"></div></div>
    </div>

    <button id="audio-btn">ğŸ”Š éŸ³æ¨‚ï¼šæ’­æ”¾ä¸­</button>

    <div class="divider"></div>
    <div class="help">
      ğŸ‘‹ æ®æ‰‹ï¼šå·¦å³ä½ç§»ï¼ˆé›¢æ•£æ­¥é€²ï¼‹æ…£æ€§ï¼‰<br>
      ğŸ”„ ä¸Šä¸‹ç§»å‹•æ‰‹æŒï¼š360 æ—‹è½‰<br>
      ğŸ– å¼µé–‹æ‰‹ï¼šçˆ†ç‚¸ç‰¹æ•ˆï¼ˆè¶Šå¼µè¶Šçˆ†ï¼‰<br>
      ğŸ‘Œ æåˆï¼šé­”æ³•å…‰é»
    </div>
  </div>

  <div id="canvas-container"><canvas width="1217" height="915" style="display: block; width: 974px; height: 732px;"></canvas></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <script>
    function createSparkle(normX, normY) {
      const x = (1 - normX) * window.innerWidth;
      const y = (normY) * window.innerHeight;
      const el = document.createElement('div');
      el.className = 'sparkle';
      el.style.left = (x - 22) + 'px';
      el.style.top  = (y - 22) + 'px';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 560);
    }

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 35, 120);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1500);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    camera.position.set(0, 3, 52);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
    keyLight.position.set(30, 40, 25);
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0x88ccff, 0.35);
    fillLight.position.set(-25, 15, 40);
    scene.add(fillLight);

    const group = new THREE.Group();
    scene.add(group);

    const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);

    // --- Tree particles ---
    const particleCount = isMobile ? 9000 : 14000;
    const treeGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const baseTargets = new Float32Array(particleCount * 3);
    const explodedTargets = new Float32Array(particleCount * 3);

    const H = 36;
    const yMin = -H * 0.55;
    const yMax =  H * 0.45;
    const maxR = 15.5;
    const spiralTurns = 10;
    const twist = 1.15;

    function radiusAtY(y) {
      const t = (y - yMin) / (yMax - yMin);
      return maxR * (1 - t) * 0.98 + 0.7;
    }

    for (let i = 0; i < particleCount * 3; i++) positions[i] = (Math.random() - 0.5) * 140;

    const gradFrom = new THREE.Color(0x22ff88);
    const gradTo   = new THREE.Color(0xffd700);

    function writeGradientColorAt(idx, t) {
      const c = gradFrom.clone().lerp(gradTo, t);
      colors[idx] = c.r; colors[idx+1] = c.g; colors[idx+2] = c.b;
    }

    for (let i = 0; i < particleCount; i++) {
      const idx = i * 3;

      const y = yMin + Math.random() * (yMax - yMin);
      const r = radiusAtY(y);

      const t = (y - yMin) / (yMax - yMin);
      const baseAngle = (t * Math.PI * 2 * spiralTurns) * twist;

      const jitter = (Math.random() - 0.5) * 0.9;
      const angle = baseAngle + jitter + (Math.random() * Math.PI * 2) * 0.12;

      const thickness = (Math.random() - 0.5) * 1.6;
      const wave = Math.sin(baseAngle * 1.6) * 0.55;
      const rr = r + thickness + wave;

      const x = Math.cos(angle) * rr;
      const z = Math.sin(angle) * rr;

      baseTargets[idx]     = x;
      baseTargets[idx + 1] = y;
      baseTargets[idx + 2] = z;

      const dir = new THREE.Vector3(x, y * 0.18, z).normalize();
      const strength = 34 + Math.random() * 22;
      explodedTargets[idx]     = x + dir.x * strength;
      explodedTargets[idx + 1] = y + dir.y * strength;
      explodedTargets[idx + 2] = z + dir.z * strength;

      writeGradientColorAt(idx, t);
    }

    treeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    treeGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const treeMaterial = new THREE.PointsMaterial({
      color: 0x22ff88,
      size: isMobile ? 0.28 : 0.2,
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending,
      vertexColors: true
    });

    const treePoints = new THREE.Points(treeGeometry, treeMaterial);
    group.add(treePoints);

    // --- Ribbon ---
    const ribbonGroup = new THREE.Group();
    group.add(ribbonGroup);

    function buildRibbon() {
      while (ribbonGroup.children.length) ribbonGroup.remove(ribbonGroup.children[0]);

      const turns = 7.2;
      const segments = isMobile ? 220 : 360;
      const curvePts = [];

      for (let i = 0; i <= segments; i++) {
        const tt = i / segments;
        const y = yMin + (yMax - yMin) * (tt * 0.98);

        const r = radiusAtY(y) * 0.92;
        const angle = tt * Math.PI * 2 * turns + Math.sin(tt * 10) * 0.16;
        const lift = 0.25 + Math.sin(tt * 12) * 0.12;

        const x = Math.cos(angle) * (r + lift);
        const z = Math.sin(angle) * (r + lift);

        curvePts.push(new THREE.Vector3(x, y, z));
      }

      const curve = new THREE.CatmullRomCurve3(curvePts);

      const tube = new THREE.TubeGeometry(curve, isMobile ? 260 : 420, 0.16, 10, false);
      const ribbonMat = new THREE.MeshStandardMaterial({
        color: 0xff4d4d,
        roughness: 0.25,
        metalness: 0.55,
        emissive: new THREE.Color(0x220000),
        emissiveIntensity: 0.55,
        transparent: true,
        opacity: 0.78
      });
      ribbonGroup.add(new THREE.Mesh(tube, ribbonMat));

      const tube2 = new THREE.TubeGeometry(curve, isMobile ? 220 : 380, 0.08, 10, false);
      const ribbonMat2 = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        roughness: 0.35,
        metalness: 0.7,
        emissive: new THREE.Color(0x332200),
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.7
      });
      const ribbon2 = new THREE.Mesh(tube2, ribbonMat2);
      ribbon2.position.y += 0.12;
      ribbonGroup.add(ribbon2);
    }
    buildRibbon();

    // --- Star ---
    function makeStarMesh() {
      const starShape = new THREE.Shape();
      const spikes = 5;
      const outerRadius = 2.0;
      const innerRadius = 0.85;

      let rot = Math.PI / 2 * 3;
      let cx = 0, cy = 0;
      let step = Math.PI / spikes;

      starShape.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        let x = cx + Math.cos(rot) * outerRadius;
        let y = cy + Math.sin(rot) * outerRadius;
        starShape.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        starShape.lineTo(x, y);
        rot += step;
      }
      starShape.lineTo(cx, cy - outerRadius);
      starShape.closePath();

      const extrudeSettings = { depth: 0.5, bevelEnabled: true, bevelThickness: 0.12, bevelSize: 0.12, bevelSegments: 2 };
      const starGeo = new THREE.ExtrudeGeometry(starShape, extrudeSettings);

      const starMat = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        roughness: 0.25,
        metalness: 0.8,
        emissive: new THREE.Color(0xffd700),
        emissiveIntensity: 0.9
      });

      const star = new THREE.Mesh(starGeo, starMat);
      star.scale.set(0.65, 0.65, 0.65);
      star.rotation.x = Math.PI * 0.05;
      star.position.y = yMax + 3.1;

      const haloCanvas = document.createElement('canvas');
      haloCanvas.width = 128; haloCanvas.height = 128;
      const ctx = haloCanvas.getContext('2d');
      const g = ctx.createRadialGradient(64,64,6,64,64,64);
      g.addColorStop(0, 'rgba(255,215,0,0.95)');
      g.addColorStop(0.35, 'rgba(255,215,0,0.35)');
      g.addColorStop(1, 'rgba(255,215,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(64,64,64,0,Math.PI*2); ctx.fill();

      const haloTex = new THREE.CanvasTexture(haloCanvas);
      const haloMat = new THREE.SpriteMaterial({ map: haloTex, transparent: true, blending: THREE.AdditiveBlending });
      const halo = new THREE.Sprite(haloMat);
      halo.scale.set(10, 10, 1);
      halo.position.y = star.position.y;

      return { star, halo };
    }
    const starPack = makeStarMesh();
    group.add(starPack.star);
    group.add(starPack.halo);

    // --- Ornaments ---
    const ornamentCount = isMobile ? 26 : 42;
    const ornamentGeo = new THREE.SphereGeometry(0.34, 12, 12);
    const ornamentMat = new THREE.MeshStandardMaterial({
      color: 0xff4d4d,
      roughness: 0.35,
      metalness: 0.45,
      emissive: new THREE.Color(0x220000),
      emissiveIntensity: 0.35
    });
    const ornaments = new THREE.InstancedMesh(ornamentGeo, ornamentMat, ornamentCount);
    group.add(ornaments);

    const ornamentPalette = [0xff4d4d, 0x6c5ce7, 0xffffff];
    const tmpObj = new THREE.Object3D();

    for (let i = 0; i < ornamentCount; i++) {
      const y = yMin + Math.random() * (yMax - yMin) * 0.9;
      const r = radiusAtY(y) * (0.86 + Math.random() * 0.08);
      const a = Math.random() * Math.PI * 2;

      tmpObj.position.set(Math.cos(a) * r, y, Math.sin(a) * r);
      tmpObj.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
      tmpObj.scale.setScalar(0.85 + Math.random() * 0.35);
      tmpObj.updateMatrix();
      ornaments.setMatrixAt(i, tmpObj.matrix);

      if (ornaments.setColorAt) {
        const c = ornamentPalette[i % ornamentPalette.length];
        ornaments.setColorAt(i, new THREE.Color(c));
        ornaments.instanceColor.needsUpdate = true;
      }
    }

    // --- Snow ---
    const snowCount = isMobile ? 1100 : 1800;
    const snowGeo = new THREE.BufferGeometry();
    const snowPos = new Float32Array(snowCount * 3);
    const snowVel = new Float32Array(snowCount);

    for (let i = 0; i < snowCount; i++) {
      const idx = i * 3;
      snowPos[idx]   = (Math.random() - 0.5) * 140;
      snowPos[idx+1] = Math.random() * 90 + 10;
      snowPos[idx+2] = (Math.random() - 0.5) * 140;
      snowVel[i] = 0.06 + Math.random() * 0.18;
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));

    const snowMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: isMobile ? 0.35 : 0.28,
      transparent: true,
      opacity: 0.65,
      blending: THREE.AdditiveBlending
    });
    const snow = new THREE.Points(snowGeo, snowMat);
    scene.add(snow);

    // --- Hands ---
    const videoElement = document.getElementById('video-preview');

    let filteredY = 0.5;
    let explodeFactor = 0.0;
    let targetExplode = 0.0;

    let treeTargetX = 0;
    const treeStep = 4.2;
    const treeXClamp = 14.0;
    let lastSwipeTime = 0;
    let lastWristX = 0;

    let lastPinchTime = 0;

    function applyHand(landmarks) {
      const now = Date.now();

      const palm = landmarks[9];
      const wrist = landmarks[0];
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const pinkyTip = landmarks[20];

      // Swipe left/right
      const wristX = 1 - wrist.x;
      const dx = wristX - lastWristX;

      if (Math.abs(dx) > 0.12 && (now - lastSwipeTime) > 520) {
        if (dx > 0) treeTargetX = Math.min(treeTargetX + treeStep, treeXClamp);
        else        treeTargetX = Math.max(treeTargetX - treeStep, -treeXClamp);
        lastSwipeTime = now;
      }
      lastWristX = wristX;
      group.position.x += (treeTargetX - group.position.x) * 0.12;

      // Up/down = 360 rotate
      let handY = palm.y;
      filteredY += (handY - filteredY) * 0.18;
      const targetRotY = (filteredY - 0.5) * (Math.PI * 2);
      group.rotation.y += (targetRotY - group.rotation.y) * 0.12;

      // Progressive explode
      const openDist = Math.hypot(thumbTip.x - pinkyTip.x, thumbTip.y - pinkyTip.y);
      const minD = 0.36;
      const maxD = 0.55;
      const t = (openDist - minD) / (maxD - minD);
      targetExplode = Math.max(0, Math.min(1, t));

      // Pinch sparkle
      const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
      if (pinchDist < 0.08 && now - lastPinchTime > 180) {
        createSparkle(indexTip.x, indexTip.y);
        starPack.halo.material.opacity = 0.95;
        lastPinchTime = now;
      }
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: isMobile ? 0 : 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        applyHand(results.multiHandLandmarks[0]);
      } else {
        targetExplode = 0.0;
        treeTargetX *= 0.92;
        group.position.x += (treeTargetX - group.position.x) * 0.06;
        group.rotation.y += (0 - group.rotation.y) * 0.05;
      }
    });

    // --- Color / Gradient toggle ---
    let useGradient = true;
    let solidColor = new THREE.Color(0x22ff88);

    function applyColorMode() {
      treeMaterial.vertexColors = useGradient;
      treeMaterial.needsUpdate = true;
      if (!useGradient) treeMaterial.color.copy(solidColor);
    }

    document.querySelectorAll('.cbtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const c = btn.dataset.c;
        solidColor = new THREE.Color(c);
        useGradient = false;
        document.getElementById('gradSwitch').classList.remove('on');
        applyColorMode();
      });
    });

    const gradSwitch = document.getElementById('gradSwitch');
    gradSwitch.addEventListener('click', () => {
      useGradient = !useGradient;
      gradSwitch.classList.toggle('on', useGradient);
      applyColorMode();
    });
    applyColorMode();

    // --- Audio ---
    const bgm = document.getElementById('bgm');
    const audioBtn = document.getElementById('audio-btn');
    let audioOn = true;

    function updateAudioBtn(){
      audioBtn.textContent = audioOn ? "ğŸ”Š éŸ³æ¨‚ï¼šæ’­æ”¾ä¸­" : "ğŸ”‡ éŸ³æ¨‚ï¼šå·²éœéŸ³";
    }
    audioBtn.addEventListener('click', () => {
      audioOn = !audioOn;
      if (bgm) bgm.muted = !audioOn;
      updateAudioBtn();
    });
    updateAudioBtn();

    // --- Animate ---
    function animate() {
      requestAnimationFrame(animate);

      explodeFactor += (targetExplode - explodeFactor) * 0.085;

      const revealCard = document.getElementById('reveal-card');
      if (revealCard) {
        if (explodeFactor > 0.72) revealCard.classList.add('show');
        else if (explodeFactor < 0.35) revealCard.classList.remove('show');
      }

      starPack.star.rotation.y += 0.02;
      starPack.star.rotation.x += 0.01;
      starPack.halo.material.opacity += (0.55 - starPack.halo.material.opacity) * 0.08;

      ribbonGroup.rotation.y += 0.002;

      const pos = treeGeometry.attributes.position.array;
      for (let i = 0; i < particleCount; i++) {
        const idx = i * 3;

        const bx = baseTargets[idx],     by = baseTargets[idx + 1], bz = baseTargets[idx + 2];
        const ex = explodedTargets[idx], ey = explodedTargets[idx + 1], ez = explodedTargets[idx + 2];

        const tx = bx + (ex - bx) * explodeFactor;
        const ty = by + (ey - by) * explodeFactor;
        const tz = bz + (ez - bz) * explodeFactor;

        pos[idx]     += (tx - pos[idx]) * 0.055;
        pos[idx + 1] += (ty - pos[idx + 1]) * 0.055;
        pos[idx + 2] += (tz - pos[idx + 2]) * 0.055;

        if (Math.random() > 0.94) {
          pos[idx]     += (Math.random() - 0.5) * 0.08;
          pos[idx + 1] += (Math.random() - 0.5) * 0.08;
          pos[idx + 2] += (Math.random() - 0.5) * 0.08;
        }
      }
      treeGeometry.attributes.position.needsUpdate = true;

      const sp = snowGeo.attributes.position.array;
      for (let i = 0; i < snowCount; i++) {
        const idx = i * 3;
        sp[idx+1] -= snowVel[i];
        sp[idx]   += Math.sin((Date.now() * 0.001) + i) * 0.002;

        if (sp[idx+1] < -10) {
          sp[idx+1] = Math.random() * 90 + 20;
          sp[idx]   = (Math.random() - 0.5) * 140;
          sp[idx+2] = (Math.random() - 0.5) * 140;
          snowVel[i] = 0.06 + Math.random() * 0.18;
        }
      }
      snowGeo.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }

    // --- Start ---
    document.getElementById('start-btn').addEventListener('click', () => {
      document.getElementById('status').style.display = 'none';

      if (bgm) {
        bgm.volume = 0.5;
        bgm.play().catch(() => {});
      }

      const cam = new Camera(videoElement, {
        onFrame: async () => { await hands.send({ image: videoElement }); },
        width: 320, height: 240
      });
      cam.start();

      animate();
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });
  </script>


</body></html>
